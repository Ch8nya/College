<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design and Analysis of Algorithms: Vertex Cover, 3SAT, and Max Clique</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #ADD8E6; /* Blue color for the background */
            font-family: Arial, sans-serif;
        }
        .content {
            margin: 0 auto;
            width: 70%; /* Content should occupy 70% of the screen */
            background-color: #FFFFFF; /* White background for the content */
            border: 1px solid #000000; /* Border around the content */
            padding: 20px;
        }
        h1, h2, p {
            margin: 0 0 15px 0;
        }
        img {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="content">
         <h1>Design and Analysis of Algorithms: A Deep Dive into Vertex Cover, 3SAT, and Max Clique</h1>
    <p>Here we will expolore the above topics</p>
    
    <h2>Vertex Cover: Exploring the Core of Graph Theory and Algorithm Design</h2>
  

    <p><strong>Introduction</strong></p>

    <p>Graph theory is a branch of mathematics that explores the relationships and connections between entities represented as vertices and edges in a graph. One fundamental concept within graph theory is the notion of a vertex cover, which plays a crucial role in various applications, ranging from network design to optimization problems. In this blog, we delve into the definition, significance, and computational challenges associated with vertex covering, with a particular focus on the minimum vertex cover problem.</p>

    <p><strong>Definition of Vertex Cover</strong></p>

    <p>A vertex cover in a graph is a subset of vertices such that every edge in the graph is incident to at least one vertex in the cover. More formally, given an undirected graph  G = (V, E) , a vertex cover is a subset of vertices  such that for every edge (u, v) in E , at least one of  u  or  v is in  C. <strong> This implies that the vertices in the vertex cover "cover" all the edges in the graph. </strong></p>

    <p>Formally, a vertex cover can be represented as a set C = {v1, v2, ..., vk}, where k is the size of the vertex cover. The goal of vertex covering is often to find the smallest possible vertex cover for a given graph, known as the minimum vertex cover problem.</p>
    <img src="3.png" alt="Vertex Cover Image">
    <p>In the above graph, set K1=(B,D) is the vertex covering of graph. Another vertex cover for the graph would be K2= (A,B,C)</p>
    <p><strong>Minimal vs Minimum Vertex covering</strong></p>
    <p>Minimal Vertex Cover:
     A minimal vertex cover in a graph is a vertex cover in which none of the vertices can be removed without compromising the cover property.<p>
    <p>In the above example, we can say that from set K1=(B,D) and K2=(A,B,C), none of the vertices can be removed, so they are minimal vertex covering. But from set K3= (A,B,C,D) A and C can be removed or only D can be removed, and it will still remain a vertex cover, so it is not a minimal vertex cover</p>
    <p>Minimum Vertex Cover:
A minimum vertex cover in a graph is a vertex cover with the smallest possible number of vertices.</p>
<p>In the above example,it is clear set K1=(B,D) has least number of vertices,i.e2</p>
          
    
    <p><strong>Significance of Vertex Covers</strong></p>

    <p>Vertex covers have a broad range of applications across different domains, making them a key concept in graph theory and computer science. Some notable applications include:</p>

    <ol>
        <li><strong>Network Design:</strong> In network design, where nodes represent devices and edges represent connections, finding a minimal vertex cover helps optimize resource allocation and connectivity while minimizing costs.</li>
        <li><strong>Optimization Problems:</strong> Many optimization problems can be modeled as graph problems, and vertex covers provide a way to address these problems efficiently. For example, in scheduling problems, a vertex cover may represent a minimal set of tasks that cover all dependencies.</li>
        <li><strong>Computer Science Algorithms:</strong> Vertex covers are used in algorithm design, particularly in the analysis of approximation algorithms and computational complexity. The minimum vertex cover problem is known to be NP-hard, making it a valuable benchmark for algorithmic research.</li>
    </ol>

    <p><strong>Computational Complexity of Vertex Cover</strong></p>

    <p>The minimum vertex cover problem is classified as NP-hard, indicating that finding the optimal solution is computationally challenging and may require exponential time in the worst case. This complexity arises from the need to explore all possible subsets of vertices to determine the smallest cover that satisfies the conditions.</p>

   
    <p><strong>Conclusion</strong></p>

    <p>In conclusion, vertex covering is a fundamental concept in graph theory with wide-ranging applications in network design, optimization, and algorithm design. The minimum vertex cover problem, being NP-hard, poses significant computational challenges, inspiring the development of approximation algorithms and heuristic methods. As technology advances, the study of vertex covers continues to contribute to the development of efficient algorithms with practical applications in diverse fields. The exploration of these concepts not only enhances our understanding of graph theory but also provides valuable tools for addressing real-world problems.</p>
    
    <p><strong>Algorithm to Find Vertex Cover of a Graph</strong><p>
        <p>1) Initialize the result as {}<br>
2) Consider a set of all edges in given graph.  Let the set be E. <br>
3) Do following while E is not empty<br>
a) Pick an arbitrary edge (u, v) from set E and add 'u' and 'v' to result<br>
b) Remove all edges from E which are either incident on u or v.<br>
4) Return result <p><br>

<h4>Implementation</h4>
<pre><code>

class Graph:
    def __init__(self, vertices):
        self.V = vertices 
        self.graph = defaultdict(list) 

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def printVertexCover(self):
        visited = [False] * self.V

        for u in range(self.V):
            if not visited[u]:
                for v in self.graph[u]:
                    if not visited[v]:
                        visited[v] = True
                        visited[u] = True
                        break

        for j in range(self.V):
            if visited[j]:
                print(j, end=' ')
        print()


g = Graph(7)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 3)
g.addEdge(3, 4)
g.addEdge(4, 5)
g.addEdge(5, 6)

g.printVertexCover()

</code></pre>

    <h2>Max Clique</h2>

    
        <h4>Understanding Cliques</h4>

    <p>A clique in an undirected graph is a set of vertices where every pair of distinct vertices is connected by an edge. To illustrate, consider a graph where vertices x, y, z, and w form a clique as each vertex is directly connected to every other vertex in the subset.</p>

    <img src="1.png" alt="Max Clique Image">

    <p>In this depiction, the set (x, y, z, w) forms a clique, representing a fundamental concept in graph theory.</p>

    <h4>Maximal Cliques:</h4>

    <p>Maximal cliques introduce a new layer to the concept of cliques. A maximal clique is a clique that cannot be expanded by adding an adjacent vertex. In simpler terms, if you were to include any more vertices in the subset, it would cease to be a clique.</p>

    <p>Let's consider the same graph again, where vertices x, y, and z form a clique. While this is a clique, it is not a maximal clique because it can be extended by adding the adjacent vertex w. Once w is introduced, the subset is no longer a maximal clique.</p>

    <h4>Maximum Cliques: </h4>

    <p>Contrastingly, maximum cliques are all about size. A maximum clique is the largest clique within a graph, boasting the maximum number of vertices among all cliques. The size of a clique is simply the count of vertices it contains.</p>

    <p>Consider a scenario where multiple cliques exist within a graph. Maximum clique involves identifying the clique with the greatest number of vertices.</p>
    
    <p>In the above example set of x,y,z and w can be called as Maximum Clique as it has the most number of vertices, i.e 6 </p>

    <h4>The Challenge of Maximum Clique</h4>


    <p>The complexity of the maximum clique problem has implications for various real-world applications, including social network analysis, bioinformatics, and optimization in computer science.</p>

    <h4>Algorithm to Find Maximal Clique</h4>
    <p>When an edge is added to the present list, check that if by adding that edge to the present list, does it still form a clique or not.<br><br>
The vertices are added until the list does not form a clique. Then, the list is backtracked to find a larger subset which forms a clique.</p>
    <h4>Implementation</h4>
    <pre><code>
MAX = 100;
n = 0;
store = [0] * MAX;
graph = [[0 for i in range(MAX)] for j in range(MAX)];
d = [0] * MAX;

def is_clique(b):
    for i in range(1, b):
        for j in range(i + 1, b):
            if (graph[store[i]][store[j]] == 0):
                return False;
    return True;

def maxCliques(i, l):
    max_ = 0;
    for j in range(i + 1, n + 1):
        store[l] = j;
        if (is_clique(l + 1)):
            max_ = max(max_, l);
            max_ = max(max_, maxCliques(j, l + 1));
    return max_;

if __name__ == '__main__':
    edges = [[1, 2], [2, 3], [4, 3], [4, 1], [4, 2]];
    size = len(edges);
    n = 4;

    for i in range(size):
        graph[edges[i][0]][edges[i][1]] = 1;
        graph[edges[i][1]][edges[i][0]] = 1;
        d[edges[i][0]] += 1;
        d[edges[i][1]] += 1;
    
    print(maxCliques(0, 1));
</code></pre>
<br>
<br>
    <h2>3-SAT</h2>
   
    <h4>Introduction to 3-SAT</h4>

    <p>In t computer science and mathematical logic, 3-SAT emerges as a distinctive type of Boolean satisfiability problem. Boolean satisfiability problems involve determining the feasibility of assigning truth values to variables within a logical formula. 3-SAT, in particular, adds a layer of complexity by structuring these formulas in conjunctive normal form (CNF), where each clause comprises precisely three literals connected by logical OR operators.</p>

    <h4>Anatomy of a 3-SAT Problem</h4>

    <p>To illustrate, a single clause in 3-SAT takes the form (A OR B OR C), and a complete 3-SAT problem consists of a collection of such clauses. The overarching objective is to ascertain whether a combination of true and false assignments to variables exists, rendering the entire formula true.</p>

    <h4>Computational Complexity and NP-Completeness</h4>

    <p>3-SAT stands as a well-studied problem in computational complexity theory. Its decision problem is classified as NP-complete, a category of problems notorious for their computational challenges. The term "NP-complete" indicates that while verifying a potential solution is relatively straightforward, finding a satisfying assignment is computationally hard.</p>

    <h4>Satisfiability</h4>

    <p>The variables A, B, and C must be strategically assigned truth values to meet the criteria of each clause. The challenge lies not only in determining whether a satisfying assignment exists but also in efficiently finding one within the vast solution space.</p>

    <p>Algorithms and methodologies designed to tackle 3-SAT vary in complexity, reflecting the intricacies of navigating Boolean formulas in CNF with three literals per clause. </p>
    <br>
    <h4>Algorithm to Find satisfying assignment for a 3-SAT problem </h4>
   <p> Check Satisfiability in a Clause (is_satisfiable):<br>
Verify if at least one literal in each clause can be assigned a truth value that satisfies the 3-SAT formula.<br><br><br>
Backtracking for Assignment (solve_3sat):<br>
Recursively explore different truth value assignments to variables until finding a combination that satisfies the entire 3-SAT formula.</p>
    <h4>Implementation</h4>
    <pre><code>
def is_satisfiable(clauses, assignment):
    for c in clauses:
        if not any(assignment[v] if v > 0 <br> else not assignment[-v] for v in c):
            return False
    return True

def solve_3sat(c, v, a, i):
    if i == len(v) + 1: return is_satisfiable(c, a)
    a[v[i]] = True
    if solve_3sat(c, v, a, i + 1): return True
    a[v[i]] = False
    return solve_3sat(c, v, a, i + 1) 

# Example usage
c = [[1, 2, -3], [-1, -2, 3], [1, -2, 3]]
v = [1, 2, 3]
a = {1: None, 2: None, 3: None}

if solve_3sat(c, v, a, 0):
    print("Satisfiable\nVariable assignments:", a)
else:
    print("Not Satisfiable")
</code></pre>

    <br>
    <p>Sources and Citations</p>
    <p><a href="https://www.geeksforgeeks.org/introduction-and-approximate-solution-for-vertex-cover-problem/" target="_blank">GeeksForGeeks.com- Algorithm and Implementation</a></p>
<p><a href="https://www.researchgate.net/figure/Clique-and-Vertex-Cover-of-a-Graph_fig2_295586640" target="_blank">Max Clique Figure: Research Gate</a></p>
<p><a href="https://www.youtube.com/watch?v=41jHknhawEw" target="_blank">Vertex Cover Figure: BB Tutorials</a></p>


    </div>
</body>
</html>
